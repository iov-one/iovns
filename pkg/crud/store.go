package crud

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"sort"

	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/cosmos/cosmos-sdk/store/prefix"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/iov-one/iovns/pkg/utils"
)

var indexPrefix = []byte{0x01}
var objectPrefix = []byte{0x00}

const ReservedSeparator = 0xFF

// Store defines a crud object store
// the store creates two sub-stores
// using prefixing, one is used to store objects
// the other one is used to store the indexes of
// the object.
type Store struct {
	cdc *codec.Codec

	indexes sdk.KVStore
	objects sdk.KVStore

	raw sdk.KVStore
}

// NewStore generates a new crud.Store given a context, a store key, the codec and a unique prefix
// that can be specified as nil if not required, the prefix generally serves the purpose of splitting
// a store into different stores in case different objects have to coexist in the same store.
func NewStore(ctx sdk.Context, key sdk.StoreKey, cdc *codec.Codec, uniquePrefix []byte) Store {
	store := ctx.KVStore(key)
	if len(uniquePrefix) != 0 {
		store = prefix.NewStore(store, uniquePrefix)
	}
	return Store{
		indexes: prefix.NewStore(store, indexPrefix),
		cdc:     cdc,
		objects: prefix.NewStore(store, objectPrefix),
		raw:     store,
	}
}

type encoder interface {
	MarshalCRUD() interface{}
	UnmarshalCRUD(cdc *codec.Codec, b []byte)
}

func (s Store) encode(o interface{}) []byte {
	if e, ok := o.(encoder); ok {
		o = e.MarshalCRUD()
	}
	return s.cdc.MustMarshalBinaryBare(o)
}

func (s Store) decode(b []byte, o interface{}) {
	e, ok := o.(encoder)
	if !ok {
		s.cdc.MustUnmarshalBinaryBare(b, o)
		return
	}
	e.UnmarshalCRUD(s.cdc, b)
}

func (s Store) Filter(filter Object) *Filtered {
	// if the primary key is specified then return that
	var primaryKeys []PrimaryKey
	pk := filter.PrimaryKey()
	if len(pk) != 0 {
		primaryKeys = append(primaryKeys, pk)
	}
	primaryKeys = append(primaryKeys, s.getPrimaryKeys(filter.SecondaryKeys())...)
	return NewFiltered(filter, primaryKeys, s)
}

// Create creates a new object in the object store and writes its indexes
func (s Store) Create(o Object) {
	// inspect
	primaryKey := o.PrimaryKey()
	// TODO this in the future needs to be autogenerated to decouple
	// the need for a primary key for objects that do not need or have it
	// and rely on indexes for filtering of different objects
	if len(primaryKey) == 0 {
		panic("empty primary key provided")
	}
	secondaryKeys := o.SecondaryKeys()
	// marshal object
	objectBytes := s.encode(o)
	// save object to object store using its primary key
	s.objects.Set(primaryKey, objectBytes)
	// generate indexes
	s.index(primaryKey, secondaryKeys)
}

// Read reads in the object store and returns false if the object is not found
// if it is found then the binary is unmarshalled into the Object.
// CONTRACT: Object must be a pointer for the unmarshalling to take effect.
func (s Store) Read(key PrimaryKey, o interface{}) (ok bool) {
	v := s.objects.Get(key)
	if v == nil {
		return
	}
	s.decode(v, o)
	return true
}

func (s Store) IterateKeys(do func(pk PrimaryKey) bool) {
	iterator := s.objects.Iterator(nil, nil)
	defer iterator.Close()
	for ; iterator.Valid(); iterator.Next() {
		if !do(iterator.Key()) {
			break
		}
	}
}

// primaryKeysInIndex finds all the primary keys in the given index
func (s Store) primaryKeysInIndex(index SecondaryKey, do func(key PrimaryKey) bool) {
	store := s.storeFromSecondaryKey(index)
	it := store.Iterator(nil, nil)
	defer it.Close()
	for ; it.Valid(); it.Next() {
		if !do(it.Key()) {
			break
		}
	}
}

// Update updates the given Object in the objects store
// after clearing the indexes and reapplying them based on the
// new update.
// To achieve so a zeroed copy of Object is created which is used to
// unmarshal the old object contents which is necessary for the un-indexing.
func (s Store) Update(pk PrimaryKey, newObject Object) {
	// get old object
	old := utils.CloneFromValue(newObject).(Object)
	s.Read(pk, old)
	// unindex old object
	s.unindex(pk, old.SecondaryKeys())
	// set new object
	s.objects.Set(pk, s.encode(newObject))
	// index new object
	s.index(pk, newObject.SecondaryKeys())
}

// Delete deletes an object from the object store after
// clearing its indexes, the object is required to provide
// a kind to clone in order to remove indexes related
// TODO in the future store the list of objects indexes inside a prefix
func (s Store) Delete(pk PrimaryKey, o Object) {
	s.deleteFromPrimary(pk, o)
}

func (s Store) deleteFromPrimary(key PrimaryKey, o Object) {
	// get value
	v := s.objects.Get(key)
	if key == nil {
		panic("unexisting key")
	}
	// clone type
	clone := utils.CloneFromValue(o).(Object)
	s.decode(v, clone)
	// remove indexes
	s.unindex(clone.PrimaryKey(), clone.SecondaryKeys())
	// remove key
	s.objects.Delete(key)
}

func (s Store) getPrimaryKeys(filters []SecondaryKey) []PrimaryKey {
	sets := make([]set, 0, len(filters))
	for _, filter := range filters {
		set := make(keySet)
		s.primaryKeysInIndex(filter, func(key PrimaryKey) bool {
			set.Insert(key)
			return true
		})
		sets = append(sets, set)
	}
	return filter(sets)
}

// unindex removes the indexes values related to the given object
func (s Store) unindex(primaryKey PrimaryKey, secondaryKeys []SecondaryKey) {
	for _, sk := range secondaryKeys {
		store := s.storeFromSecondaryKey(sk)
		store.Delete(primaryKey)
	}
}

// index indexes the secondary key values related to the object
func (s Store) index(primaryKey PrimaryKey, secondaryKeys []SecondaryKey) {
	for _, sk := range secondaryKeys {
		store := s.storeFromSecondaryKey(sk)
		store.Set(primaryKey, []byte{})
	}
}

func (s Store) storeFromSecondaryKey(sk SecondaryKey) sdk.KVStore {
	fixSecondaryKey(&sk)
	indexPrefix := prefix.NewStore(s.indexes, sk.StorePrefix)
	return prefix.NewStore(indexPrefix, sk.Key)
}

// Object defines an object in which we can do crud operations
type Object interface {
	// PrimaryKey returns the unique key of the object
	PrimaryKey() PrimaryKey
	// SecondaryKeys returns the secondary keys used to index the object
	SecondaryKeys() []SecondaryKey
}

// PrimaryKey defines a primary key, which is a secondary key, under the hood, but with a fixed 0x0 prefix
type PrimaryKey []byte

// SecondaryKey defines a secondary key for the object
type SecondaryKey struct {
	// Key is the byte key which identifies the byte key prefix used to iterate of the index of the secondary key
	Key []byte
	// StorePrefix is the prefix of the index, necessary to divide one index from another
	// TODO this is not safe, because of prefixes overlapping
	StorePrefix []byte
}

// fixSecondaryKey encodes key value which contains the reserved separator by base64-encoding them
// this is necessary because we're dealing with a prefixed KVStore which, if we iterate, is going to
// iterate over bytes contained in a key, so if we assume we have:
// KeyA = [0x1]
// KeyB = [0x1, 0x2]
// during iteration, in case we wanted to iterate over KeyA only we'd end up in KeyB domain too because
// KeyB starts with KeyA, so to avoid this we put a full stop separator which we know other keys can not contain
func fixSecondaryKey(sk *SecondaryKey) {
	if len(sk.StorePrefix) != 1 {
		panic("invalid prefix length")
	}
	if bytes.Contains(sk.Key, []byte{ReservedSeparator}) {
		dst := make([]byte, base64.RawStdEncoding.EncodedLen(len(sk.Key)))
		base64.RawStdEncoding.Encode(dst, sk.Key)
		sk.Key = dst
	}
	sk.Key = append(sk.Key, ReservedSeparator)
}

type Filtered struct {
	counter     int
	nKeys       int
	underlying  Object
	primaryKeys []PrimaryKey
	store       Store
}

func NewFiltered(obj Object, keys []PrimaryKey, store Store) *Filtered {
	// sort deterministically
	sort.Slice(keys, func(i, j int) bool {
		return bytes.Compare(keys[i], keys[j]) < 0
	})
	return &Filtered{
		counter:     0,
		nKeys:       len(keys),
		underlying:  obj,
		primaryKeys: keys,
		store:       store,
	}
}

func (f *Filtered) Read(target interface{}) {
	ok := f.store.Read(f.currKey(), target)
	if !ok {
		panic(fmt.Sprintf("can't find object using primary key: %s", f.currKey()))
	}
}

func (f *Filtered) Update(o Object) {
	f.store.Update(f.currKey(), o)
}

func (f *Filtered) Delete() {
	if !f.Valid() {
		return
	}
	f.store.deleteFromPrimary(f.currKey(), f.underlying)
}

func (f *Filtered) currKey() PrimaryKey {
	if f.counter == 0 && f.nKeys == 0 {
		panic("iterating an empty filter is not valid")
	}
	return f.primaryKeys[f.counter]
}

func (f *Filtered) Next() {
	f.counter++
}

func (f *Filtered) Valid() bool {
	return f.counter < f.nKeys
}
